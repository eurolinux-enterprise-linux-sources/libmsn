<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libmsn: /home/salem/libmsn/tags/libmsn-4.2/msn/xmlParser.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libmsn&#160;<span id="projectnumber">4.2.1</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/salem/libmsn/tags/libmsn-4.2/msn/xmlParser.h</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00038"></a>00038 <span class="preprocessor">#ifndef __INCLUDE_XML_NODE__</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span><span class="preprocessor">#define __INCLUDE_XML_NODE__</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="preprocessor">#ifdef _UNICODE</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span>    <span class="comment">// If you comment the next &quot;define&quot; line then the library will never &quot;switch to&quot; _UNICODE (wchar_t*) mode (16/32 bits per characters).</span>
<a name="l00045"></a>00045     <span class="comment">// This is useful when you get error messages like:</span>
<a name="l00046"></a>00046     <span class="comment">//    &#39;XMLNode::openFileHelper&#39; : cannot convert parameter 2 from &#39;const char [5]&#39; to &#39;const wchar_t *&#39;</span>
<a name="l00047"></a>00047     <span class="comment">// The _XMLWIDECHAR preprocessor variable force the XMLParser library into either utf16/32-mode (the proprocessor variable</span>
<a name="l00048"></a>00048     <span class="comment">// must be defined) or utf8-mode(the pre-processor variable must be undefined).</span>
<a name="l00049"></a>00049 <span class="preprocessor">#define _XMLWIDECHAR</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span>
<a name="l00052"></a>00052 <span class="preprocessor">#if defined(WIN32) || defined(UNDER_CE)</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span>    <span class="comment">// comment the next line if you are under windows and the compiler is not Microsoft Visual Studio (6.0 or .NET)</span>
<a name="l00054"></a>00054 <span class="preprocessor">#define _XMLWINDOWS</span>
<a name="l00055"></a>00055 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span>
<a name="l00057"></a>00057 <span class="preprocessor">#ifdef XMLDLLENTRY</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span><span class="preprocessor">#undef XMLDLLENTRY</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span><span class="preprocessor">#ifdef _USE_XMLPARSER_DLL</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span><span class="preprocessor">#ifdef _DLL_EXPORTS_</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span><span class="preprocessor">#define XMLDLLENTRY __declspec(dllexport)</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span><span class="preprocessor">#define XMLDLLENTRY __declspec(dllimport)</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span><span class="preprocessor">#define XMLDLLENTRY</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00069"></a>00069 <span class="preprocessor"></span>
<a name="l00070"></a>00070     <span class="comment">// uncomment the next line if you want no support for wchar_t* (no need for the &lt;wchar.h&gt; or &lt;tchar.h&gt; libraries anymore to compile)</span>
<a name="l00071"></a>00071     <span class="comment">//#define XML_NO_WIDE_CHAR</span>
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 <span class="preprocessor">#ifdef XML_NO_WIDE_CHAR</span>
<a name="l00074"></a>00074 <span class="preprocessor"></span><span class="preprocessor">#undef _XMLWINDOWS</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span><span class="preprocessor">#undef _XMLWIDECHAR</span>
<a name="l00076"></a>00076 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00077"></a>00077 <span class="preprocessor"></span>
<a name="l00078"></a>00078 <span class="preprocessor">#ifdef _XMLWINDOWS</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span><span class="preprocessor">#include &lt;tchar.h&gt;</span>
<a name="l00080"></a>00080 <span class="preprocessor">#else</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span><span class="preprocessor">#define XMLDLLENTRY</span>
<a name="l00082"></a>00082 <span class="preprocessor"></span><span class="preprocessor">#ifndef XML_NO_WIDE_CHAR</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span><span class="preprocessor">#include &lt;wchar.h&gt;</span> <span class="comment">// to have &#39;wcsrtombs&#39; for ANSI version</span>
<a name="l00084"></a>00084                        <span class="comment">// to have &#39;mbsrtowcs&#39; for WIDECHAR version</span>
<a name="l00085"></a>00085 <span class="preprocessor">#endif</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span>
<a name="l00088"></a>00088     <span class="comment">// Some common types for char set portable code</span>
<a name="l00089"></a>00089 <span class="preprocessor">#ifdef _XMLWIDECHAR</span>
<a name="l00090"></a>00090 <span class="preprocessor"></span><span class="preprocessor">        #ifndef _T</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span><span class="preprocessor">            #define _T(c) L ## c</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span><span class="preprocessor">        #endif</span>
<a name="l00093"></a>00093 <span class="preprocessor"></span><span class="preprocessor">        #define XMLCSTR const wchar_t *</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span><span class="preprocessor">        #define XMLSTR  wchar_t *</span>
<a name="l00095"></a>00095 <span class="preprocessor"></span><span class="preprocessor">        #define XMLCHAR wchar_t</span>
<a name="l00096"></a>00096 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00097"></a>00097 <span class="preprocessor"></span><span class="preprocessor">        #ifndef _T</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span><span class="preprocessor">            #define _T(c) c</span>
<a name="l00099"></a>00099 <span class="preprocessor"></span><span class="preprocessor">        #endif</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span><span class="preprocessor">        #define XMLCSTR const char *</span>
<a name="l00101"></a>00101 <span class="preprocessor"></span><span class="preprocessor">        #define XMLSTR  char *</span>
<a name="l00102"></a>00102 <span class="preprocessor"></span><span class="preprocessor">        #define XMLCHAR char</span>
<a name="l00103"></a>00103 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00104"></a>00104 <span class="preprocessor"></span><span class="preprocessor">#ifndef FALSE</span>
<a name="l00105"></a>00105 <span class="preprocessor"></span><span class="preprocessor">        #define FALSE 0</span>
<a name="l00106"></a>00106 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* FALSE */</span>
<a name="l00107"></a>00107 <span class="preprocessor">#ifndef TRUE</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span><span class="preprocessor">        #define TRUE 1</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* TRUE */</span>
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 
<a name="l00112"></a>00112     <span class="comment">// Enumeration for XML parse errors.</span>
<a name="l00113"></a>00113     <span class="keyword">typedef</span> <span class="keyword">enum</span> XMLError
<a name="l00114"></a>00114     {
<a name="l00115"></a>00115         eXMLErrorNone = 0,
<a name="l00116"></a>00116         eXMLErrorMissingEndTag,
<a name="l00117"></a>00117         eXMLErrorEmpty,
<a name="l00118"></a>00118         eXMLErrorFirstNotStartTag,
<a name="l00119"></a>00119         eXMLErrorMissingTagName,
<a name="l00120"></a>00120         eXMLErrorMissingEndTagName,
<a name="l00121"></a>00121         eXMLErrorNoMatchingQuote,
<a name="l00122"></a>00122         eXMLErrorUnmatchedEndTag,
<a name="l00123"></a>00123         eXMLErrorUnmatchedEndClearTag,
<a name="l00124"></a>00124         eXMLErrorUnexpectedToken,
<a name="l00125"></a>00125         eXMLErrorInvalidTag,
<a name="l00126"></a>00126         eXMLErrorNoElements,
<a name="l00127"></a>00127         eXMLErrorFileNotFound,
<a name="l00128"></a>00128         eXMLErrorFirstTagNotFound,
<a name="l00129"></a>00129         eXMLErrorUnknownCharacterEntity,
<a name="l00130"></a>00130         eXMLErrorCharConversionError,
<a name="l00131"></a>00131         eXMLErrorCannotOpenWriteFile,
<a name="l00132"></a>00132         eXMLErrorCannotWriteFile,
<a name="l00133"></a>00133 
<a name="l00134"></a>00134         eXMLErrorBase64DataSizeIsNotMultipleOf4,
<a name="l00135"></a>00135         eXMLErrorBase64DecodeIllegalCharacter,
<a name="l00136"></a>00136         eXMLErrorBase64DecodeTruncatedData,
<a name="l00137"></a>00137         eXMLErrorBase64DecodeBufferTooSmall
<a name="l00138"></a>00138     } XMLError;
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 
<a name="l00141"></a>00141     <span class="comment">// Enumeration used to manage type of data. Use in conjunction with structure XMLNodeContents</span>
<a name="l00142"></a>00142     <span class="keyword">typedef</span> <span class="keyword">enum</span> XMLElementType
<a name="l00143"></a>00143     {
<a name="l00144"></a>00144         eNodeChild=0,
<a name="l00145"></a>00145         eNodeAttribute=1,
<a name="l00146"></a>00146         eNodeText=2,
<a name="l00147"></a>00147         eNodeClear=3,
<a name="l00148"></a>00148         eNodeNULL=4
<a name="l00149"></a>00149     } XMLElementType;
<a name="l00150"></a>00150 
<a name="l00151"></a>00151     <span class="comment">// Structure used to obtain error details if the parse fails.</span>
<a name="l00152"></a><a class="code" href="structXMLResults.html">00152</a>     <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structXMLResults.html">XMLResults</a>
<a name="l00153"></a>00153     {
<a name="l00154"></a>00154         <span class="keyword">enum</span> XMLError error;
<a name="l00155"></a>00155         <span class="keywordtype">int</span>  nLine,nColumn;
<a name="l00156"></a>00156     } <a class="code" href="structXMLResults.html">XMLResults</a>;
<a name="l00157"></a>00157 
<a name="l00158"></a>00158     <span class="comment">// Structure for XML clear (unformatted) node (usually comments)</span>
<a name="l00159"></a><a class="code" href="structXMLClear.html">00159</a>     <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structXMLClear.html">XMLClear</a> {
<a name="l00160"></a>00160         XMLCSTR lpszValue; XMLCSTR lpszOpenTag; XMLCSTR lpszCloseTag;
<a name="l00161"></a>00161     } <a class="code" href="structXMLClear.html">XMLClear</a>;
<a name="l00162"></a>00162 
<a name="l00163"></a>00163     <span class="comment">// Structure for XML attribute.</span>
<a name="l00164"></a><a class="code" href="structXMLAttribute.html">00164</a>     <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structXMLAttribute.html">XMLAttribute</a> {
<a name="l00165"></a>00165         XMLCSTR lpszName; XMLCSTR lpszValue;
<a name="l00166"></a>00166     } <a class="code" href="structXMLAttribute.html">XMLAttribute</a>;
<a name="l00167"></a>00167 
<a name="l00168"></a>00168     <span class="keyword">struct </span><a class="code" href="structXMLNodeContents.html">XMLNodeContents</a>;
<a name="l00169"></a>00169 
<a name="l00170"></a><a class="code" href="structXMLNode.html">00170</a>     <span class="keyword">typedef</span> <span class="keyword">struct </span>XMLDLLENTRY <a class="code" href="structXMLNode.html">XMLNode</a>
<a name="l00171"></a>00171     {
<a name="l00172"></a>00172       <span class="keyword">private</span>:
<a name="l00173"></a>00173 
<a name="l00174"></a>00174         <span class="keyword">struct </span>XMLNodeDataTag;
<a name="l00175"></a>00175 
<a name="l00176"></a>00176         <span class="comment">// protected constructors: use one of these four methods to get your first instance of XMLNode:</span>
<a name="l00177"></a>00177         <span class="comment">//  - parseString</span>
<a name="l00178"></a>00178         <span class="comment">//  - parseFile</span>
<a name="l00179"></a>00179         <span class="comment">//  - openFileHelper</span>
<a name="l00180"></a>00180         <span class="comment">//  - createXMLTopNode</span>
<a name="l00181"></a>00181         <a class="code" href="structXMLNode.html">XMLNode</a>(<span class="keyword">struct</span> XMLNodeDataTag *pParent, XMLSTR lpszName, <span class="keywordtype">char</span> isDeclaration);
<a name="l00182"></a>00182         <a class="code" href="structXMLNode.html">XMLNode</a>(<span class="keyword">struct</span> XMLNodeDataTag *p);
<a name="l00183"></a>00183 
<a name="l00184"></a>00184       <span class="keyword">public</span>:
<a name="l00185"></a>00185 
<a name="l00186"></a>00186         <span class="comment">// You can create your first instance of XMLNode with these 4 functions:</span>
<a name="l00187"></a>00187         <span class="comment">// (see complete explanation of parameters below)</span>
<a name="l00188"></a>00188 
<a name="l00189"></a>00189         <span class="keyword">static</span> <a class="code" href="structXMLNode.html">XMLNode</a> createXMLTopNode(XMLCSTR lpszName, <span class="keywordtype">char</span> isDeclaration=FALSE);
<a name="l00190"></a>00190         <span class="keyword">static</span> <a class="code" href="structXMLNode.html">XMLNode</a> parseString   (XMLCSTR  lpXMLString, XMLCSTR tag=NULL, <a class="code" href="structXMLResults.html">XMLResults</a> *pResults=NULL);
<a name="l00191"></a>00191         <span class="keyword">static</span> <a class="code" href="structXMLNode.html">XMLNode</a> parseFile     (XMLCSTR     filename, XMLCSTR tag=NULL, <a class="code" href="structXMLResults.html">XMLResults</a> *pResults=NULL);
<a name="l00192"></a>00192         <span class="keyword">static</span> <a class="code" href="structXMLNode.html">XMLNode</a> openFileHelper(XMLCSTR     filename, XMLCSTR tag=NULL                           );
<a name="l00193"></a>00193 
<a name="l00194"></a>00194         <span class="comment">// The tag parameter should be the name of the first tag inside the XML file.</span>
<a name="l00195"></a>00195         <span class="comment">// If the tag parameter is omitted, the 3 functions return a node that represents</span>
<a name="l00196"></a>00196         <span class="comment">// the head of the xml document including the declaration term (&lt;? ... ?&gt;).</span>
<a name="l00197"></a>00197 
<a name="l00198"></a>00198         <span class="comment">// The &quot;openFileHelper&quot; reports to the screen all the warnings &amp; errors that occurred during</span>
<a name="l00199"></a>00199         <span class="comment">// parsing of the XML file. Since each application has its own way to report and deal with errors,</span>
<a name="l00200"></a>00200         <span class="comment">// you should rather use the &quot;parseFile&quot; function to parse XML files and program yourself thereafter</span>
<a name="l00201"></a>00201         <span class="comment">// an &quot;error reporting&quot; tailored for your needs (instead of using the very crude &quot;error reporting&quot;</span>
<a name="l00202"></a>00202         <span class="comment">// mechanism included inside the &quot;openFileHelper&quot; function).</span>
<a name="l00203"></a>00203 
<a name="l00204"></a>00204         <span class="comment">// If the XML document is corrupted:</span>
<a name="l00205"></a>00205         <span class="comment">//   * The &quot;openFileHelper&quot; method will:</span>
<a name="l00206"></a>00206         <span class="comment">//         - display an error message on the console (or inside a messageBox for windows).</span>
<a name="l00207"></a>00207         <span class="comment">//         - stop execution (exit).</span>
<a name="l00208"></a>00208         <span class="comment">//     I suggest that you write your own &quot;openFileHelper&quot; method tailored to your needs.</span>
<a name="l00209"></a>00209     <span class="comment">//   * The 2 other methods will initialize the &quot;pResults&quot; variable with some information that</span>
<a name="l00210"></a>00210     <span class="comment">//     can be used to trace the error.</span>
<a name="l00211"></a>00211     <span class="comment">//   * If you still want to parse the file, you can use the APPROXIMATE_PARSING option as</span>
<a name="l00212"></a>00212     <span class="comment">//     explained inside the note at the beginning of the &quot;xmlParser.cpp&quot; file.</span>
<a name="l00213"></a>00213     <span class="comment">// You can have a user-friendly explanation of the parsing error with this function:</span>
<a name="l00214"></a>00214     <span class="keyword">static</span> XMLCSTR getError(XMLError error);
<a name="l00215"></a>00215     <span class="keyword">static</span> XMLCSTR getVersion();
<a name="l00216"></a>00216 
<a name="l00217"></a>00217     XMLCSTR getName() <span class="keyword">const</span>;                                         <span class="comment">// name of the node</span>
<a name="l00218"></a>00218     XMLCSTR getText(<span class="keywordtype">int</span> i=0) <span class="keyword">const</span>;                                  <span class="comment">// return ith text field</span>
<a name="l00219"></a>00219     <span class="keywordtype">int</span> nText() <span class="keyword">const</span>;                                               <span class="comment">// nbr of text field</span>
<a name="l00220"></a>00220     <a class="code" href="structXMLNode.html">XMLNode</a> getParentNode() <span class="keyword">const</span>;                                   <span class="comment">// return the parent node</span>
<a name="l00221"></a>00221     <a class="code" href="structXMLNode.html">XMLNode</a> getChildNode(<span class="keywordtype">int</span> i=0) <span class="keyword">const</span>;                             <span class="comment">// return ith child node</span>
<a name="l00222"></a>00222     <a class="code" href="structXMLNode.html">XMLNode</a> getChildNode(XMLCSTR name, <span class="keywordtype">int</span> i)  <span class="keyword">const</span>;                <span class="comment">// return ith child node with specific name</span>
<a name="l00223"></a>00223                                                                      <span class="comment">//     (return an empty node if failing)</span>
<a name="l00224"></a>00224     <a class="code" href="structXMLNode.html">XMLNode</a> getChildNode(XMLCSTR name, <span class="keywordtype">int</span> *i=NULL) <span class="keyword">const</span>;           <span class="comment">// return next child node with specific name</span>
<a name="l00225"></a>00225                                                                      <span class="comment">//     (return an empty node if failing)</span>
<a name="l00226"></a>00226     <a class="code" href="structXMLNode.html">XMLNode</a> getChildNodeWithAttribute(XMLCSTR tagName,               <span class="comment">// return child node with specific name/attribute</span>
<a name="l00227"></a>00227                                       XMLCSTR attributeName,         <span class="comment">//     (return an empty node if failing)</span>
<a name="l00228"></a>00228                                       XMLCSTR attributeValue=NULL,   <span class="comment">//</span>
<a name="l00229"></a>00229                                       <span class="keywordtype">int</span> *i=NULL)  <span class="keyword">const</span>;           <span class="comment">//</span>
<a name="l00230"></a>00230     <span class="keywordtype">int</span> nChildNode(XMLCSTR name) <span class="keyword">const</span>;                              <span class="comment">// return the number of child node with specific name</span>
<a name="l00231"></a>00231     <span class="keywordtype">int</span> nChildNode() <span class="keyword">const</span>;                                          <span class="comment">// nbr of child node</span>
<a name="l00232"></a>00232     <a class="code" href="structXMLAttribute.html">XMLAttribute</a> getAttribute(<span class="keywordtype">int</span> i=0) <span class="keyword">const</span>;                        <span class="comment">// return ith attribute</span>
<a name="l00233"></a>00233     XMLCSTR      getAttributeName(<span class="keywordtype">int</span> i=0) <span class="keyword">const</span>;                    <span class="comment">// return ith attribute name</span>
<a name="l00234"></a>00234     XMLCSTR      getAttributeValue(<span class="keywordtype">int</span> i=0) <span class="keyword">const</span>;                   <span class="comment">// return ith attribute value</span>
<a name="l00235"></a>00235     <span class="keywordtype">char</span>  isAttributeSet(XMLCSTR name) <span class="keyword">const</span>;                        <span class="comment">// test if an attribute with a specific name is given</span>
<a name="l00236"></a>00236     XMLCSTR getAttribute(XMLCSTR name, <span class="keywordtype">int</span> i) <span class="keyword">const</span>;                 <span class="comment">// return ith attribute content with specific name</span>
<a name="l00237"></a>00237                                                                      <span class="comment">//     (return a NULL if failing)</span>
<a name="l00238"></a>00238     XMLCSTR getAttribute(XMLCSTR name, <span class="keywordtype">int</span> *i=NULL) <span class="keyword">const</span>;           <span class="comment">// return next attribute content with specific name</span>
<a name="l00239"></a>00239                                                                      <span class="comment">//     (return a NULL if failing)</span>
<a name="l00240"></a>00240     <span class="keywordtype">int</span> nAttribute() <span class="keyword">const</span>;                                          <span class="comment">// nbr of attribute</span>
<a name="l00241"></a>00241     <a class="code" href="structXMLClear.html">XMLClear</a> getClear(<span class="keywordtype">int</span> i=0) <span class="keyword">const</span>;                                <span class="comment">// return ith clear field (comments)</span>
<a name="l00242"></a>00242     <span class="keywordtype">int</span> nClear() <span class="keyword">const</span>;                                              <span class="comment">// nbr of clear field</span>
<a name="l00243"></a>00243     XMLSTR createXMLString(<span class="keywordtype">int</span> nFormat=1, <span class="keywordtype">int</span> *pnSize=NULL) <span class="keyword">const</span>;   <span class="comment">// create XML string starting from current XMLNode</span>
<a name="l00244"></a>00244                                                                      <span class="comment">// if nFormat==0, no formatting is required</span>
<a name="l00245"></a>00245                                                                      <span class="comment">// otherwise this returns an user friendly XML string from a</span>
<a name="l00246"></a>00246                                                                      <span class="comment">// given element with appropriate white spaces and carriage returns.</span>
<a name="l00247"></a>00247                                                                      <span class="comment">// if pnSize is given it returns the size in character of the string.</span>
<a name="l00248"></a>00248     XMLError writeToFile(XMLCSTR filename, <span class="keyword">const</span> <span class="keywordtype">char</span> *encoding=NULL, <span class="keywordtype">char</span> nFormat=1) <span class="keyword">const</span>;
<a name="l00249"></a>00249                                                                      <span class="comment">// Save the content of an xmlNode inside a file.</span>
<a name="l00250"></a>00250                                                                      <span class="comment">// The nFormat parameter has the same meaning as in the</span>
<a name="l00251"></a>00251                                                                      <span class="comment">// createXMLString function. If the global parameter</span>
<a name="l00252"></a>00252                                                                      <span class="comment">// &quot;characterEncoding==encoding_UTF8&quot;, then the &quot;encoding&quot; parameter is</span>
<a name="l00253"></a>00253                                                                      <span class="comment">// ignored and always set to &quot;utf-8&quot;. If the global parameter</span>
<a name="l00254"></a>00254                                                                      <span class="comment">// &quot;characterEncoding==encoding_ShiftJIS&quot;, then the &quot;encoding&quot; parameter</span>
<a name="l00255"></a>00255                                                                      <span class="comment">// is ignored and always set to &quot;SHIFT-JIS&quot;. If &quot;_XMLWIDECHAR=1&quot;, then</span>
<a name="l00256"></a>00256                                                                      <span class="comment">// the &quot;encoding&quot; parameter is ignored and always set to &quot;utf-16&quot;.</span>
<a name="l00257"></a>00257                                                                      <span class="comment">// If no &quot;encoding&quot; parameter is given the &quot;ISO-8859-1&quot; encoding is used.</span>
<a name="l00258"></a>00258     <a class="code" href="structXMLNodeContents.html">XMLNodeContents</a> enumContents(<span class="keywordtype">int</span> i) <span class="keyword">const</span>;                       <span class="comment">// enumerate all the different contents (attribute,child,text,</span>
<a name="l00259"></a>00259                                                                      <span class="comment">//     clear) of the current XMLNode. The order is reflecting</span>
<a name="l00260"></a>00260                                                                      <span class="comment">//     the order of the original file/string.</span>
<a name="l00261"></a>00261                                                                      <span class="comment">//     NOTE: 0 &lt;= i &lt; nElement();</span>
<a name="l00262"></a>00262     <span class="keywordtype">int</span> nElement() <span class="keyword">const</span>;                                            <span class="comment">// nbr of different contents for current node</span>
<a name="l00263"></a>00263     <span class="keywordtype">char</span> isEmpty() <span class="keyword">const</span>;                                            <span class="comment">// is this node Empty?</span>
<a name="l00264"></a>00264     <span class="keywordtype">char</span> isDeclaration() <span class="keyword">const</span>;                                      <span class="comment">// is this node a declaration &lt;? .... ?&gt;</span>
<a name="l00265"></a>00265     <span class="keyword">static</span> <a class="code" href="structXMLNode.html">XMLNode</a> emptyNode();                                      <span class="comment">// return XMLNode::emptyXMLNode;</span>
<a name="l00266"></a>00266 
<a name="l00267"></a>00267 <span class="comment">// to allow shallow/fast copy:</span>
<a name="l00268"></a>00268     ~<a class="code" href="structXMLNode.html">XMLNode</a>();
<a name="l00269"></a>00269     <a class="code" href="structXMLNode.html">XMLNode</a>(<span class="keyword">const</span> <a class="code" href="structXMLNode.html">XMLNode</a> &amp;A);
<a name="l00270"></a>00270     <a class="code" href="structXMLNode.html">XMLNode</a>&amp; operator=( <span class="keyword">const</span> <a class="code" href="structXMLNode.html">XMLNode</a>&amp; A );
<a name="l00271"></a>00271 
<a name="l00272"></a>00272     <a class="code" href="structXMLNode.html">XMLNode</a>(): d(NULL){};
<a name="l00273"></a>00273     <span class="keyword">static</span> <a class="code" href="structXMLNode.html">XMLNode</a> emptyXMLNode;
<a name="l00274"></a>00274     <span class="keyword">static</span> <a class="code" href="structXMLClear.html">XMLClear</a> emptyXMLClear;
<a name="l00275"></a>00275     <span class="keyword">static</span> <a class="code" href="structXMLAttribute.html">XMLAttribute</a> emptyXMLAttribute;
<a name="l00276"></a>00276 
<a name="l00277"></a>00277     <span class="comment">// The following functions allows you to create from scratch (or update) a XMLNode structure</span>
<a name="l00278"></a>00278     <span class="comment">// Start by creating your top node with the &quot;createXMLTopNode&quot; function and then add new nodes with the &quot;addChild&quot; function.</span>
<a name="l00279"></a>00279     <span class="comment">// The parameter &#39;pos&#39; gives the position where the childNode, the text or the XMLClearTag will be inserted.</span>
<a name="l00280"></a>00280     <span class="comment">// The default value (pos=-1) inserts at the end. The value (pos=0) insert at the beginning (Insertion at the beginning is slower than at the end).</span>
<a name="l00281"></a>00281     <span class="comment">// REMARK: 0 &lt;= pos &lt; nChild()+nText()+nClear()</span>
<a name="l00282"></a>00282     <a class="code" href="structXMLNode.html">XMLNode</a>       addChild(XMLCSTR lpszName, <span class="keywordtype">char</span> isDeclaration=FALSE, <span class="keywordtype">int</span> pos=-1);
<a name="l00283"></a>00283     <a class="code" href="structXMLAttribute.html">XMLAttribute</a> *addAttribute(XMLCSTR lpszName, XMLCSTR lpszValuev);
<a name="l00284"></a>00284     XMLCSTR       addText(XMLCSTR lpszValue, <span class="keywordtype">int</span> pos=-1);
<a name="l00285"></a>00285     <a class="code" href="structXMLClear.html">XMLClear</a>     *addClear(XMLCSTR lpszValue, XMLCSTR lpszOpen=NULL, XMLCSTR lpszClose=NULL, <span class="keywordtype">int</span> pos=-1);
<a name="l00286"></a>00286                                                                     <span class="comment">// default values: lpszOpen =&quot;&lt;![CDATA[&quot;</span>
<a name="l00287"></a>00287                                                                     <span class="comment">//                 lpszClose=&quot;]]&gt;&quot;</span>
<a name="l00288"></a>00288     <a class="code" href="structXMLNode.html">XMLNode</a>       addChild(<a class="code" href="structXMLNode.html">XMLNode</a> nodeToAdd, <span class="keywordtype">int</span> pos=-1);          <span class="comment">// If the &quot;nodeToAdd&quot; has some parents, it will be detached</span>
<a name="l00289"></a>00289                                                                     <span class="comment">// from it&#39;s parents before being attached to the current XMLNode</span>
<a name="l00290"></a>00290     <span class="comment">// Some update functions:</span>
<a name="l00291"></a>00291     XMLCSTR       updateName(XMLCSTR lpszName);                                                    <span class="comment">// change node&#39;s name</span>
<a name="l00292"></a>00292     <a class="code" href="structXMLAttribute.html">XMLAttribute</a> *updateAttribute(<a class="code" href="structXMLAttribute.html">XMLAttribute</a> *newAttribute, <a class="code" href="structXMLAttribute.html">XMLAttribute</a> *oldAttribute);         <span class="comment">// if the attribute to update is missing, a new one will be added</span>
<a name="l00293"></a>00293     <a class="code" href="structXMLAttribute.html">XMLAttribute</a> *updateAttribute(XMLCSTR lpszNewValue, XMLCSTR lpszNewName=NULL,<span class="keywordtype">int</span> i=0);         <span class="comment">// if the attribute to update is missing, a new one will be added</span>
<a name="l00294"></a>00294     <a class="code" href="structXMLAttribute.html">XMLAttribute</a> *updateAttribute(XMLCSTR lpszNewValue, XMLCSTR lpszNewName,XMLCSTR lpszOldName);  <span class="comment">// set lpszNewName=NULL if you don&#39;t want to change the name of the attribute</span>
<a name="l00295"></a>00295                                                                                                    <span class="comment">// if the attribute to update is missing, a new one will be added</span>
<a name="l00296"></a>00296     XMLCSTR       updateText(XMLCSTR lpszNewValue, <span class="keywordtype">int</span> i=0);                                       <span class="comment">// if the text to update is missing, a new one will be added</span>
<a name="l00297"></a>00297     XMLCSTR       updateText(XMLCSTR lpszNewValue, XMLCSTR lpszOldValue);                          <span class="comment">// if the text to update is missing, a new one will be added</span>
<a name="l00298"></a>00298     <a class="code" href="structXMLClear.html">XMLClear</a>     *updateClear(XMLCSTR lpszNewContent, <span class="keywordtype">int</span> i=0);                                    <span class="comment">// if the clearTag to update is missing, a new one will be added</span>
<a name="l00299"></a>00299     <a class="code" href="structXMLClear.html">XMLClear</a>     *updateClear(<a class="code" href="structXMLClear.html">XMLClear</a> *newP,<a class="code" href="structXMLClear.html">XMLClear</a> *oldP);                                      <span class="comment">// if the clearTag to update is missing, a new one will be added</span>
<a name="l00300"></a>00300     <a class="code" href="structXMLClear.html">XMLClear</a>     *updateClear(XMLCSTR lpszNewValue, XMLCSTR lpszOldValue);                         <span class="comment">// if the clearTag to update is missing, a new one will be added</span>
<a name="l00301"></a>00301 
<a name="l00302"></a>00302     <span class="comment">// Some deletion functions:</span>
<a name="l00303"></a>00303     <span class="keywordtype">void</span> deleteNodeContent(<span class="keywordtype">char</span> force=0);  <span class="comment">// delete the content of this XMLNode and the subtree.</span>
<a name="l00304"></a>00304                                            <span class="comment">// if force=0, while (references to this node still exist), no memory free occurs</span>
<a name="l00305"></a>00305                                            <span class="comment">// if force=1, always delete the content of this XMLNode and the subtree and free associated memory</span>
<a name="l00306"></a>00306     <span class="keywordtype">void</span> deleteAttribute(XMLCSTR lpszName);
<a name="l00307"></a>00307     <span class="keywordtype">void</span> deleteAttribute(<span class="keywordtype">int</span> i=0);
<a name="l00308"></a>00308     <span class="keywordtype">void</span> deleteAttribute(<a class="code" href="structXMLAttribute.html">XMLAttribute</a> *anAttribute);
<a name="l00309"></a>00309     <span class="keywordtype">void</span> deleteText(<span class="keywordtype">int</span> i=0);
<a name="l00310"></a>00310     <span class="keywordtype">void</span> deleteText(XMLCSTR lpszValue);
<a name="l00311"></a>00311     <span class="keywordtype">void</span> deleteClear(<span class="keywordtype">int</span> i=0);
<a name="l00312"></a>00312     <span class="keywordtype">void</span> deleteClear(<a class="code" href="structXMLClear.html">XMLClear</a> *p);
<a name="l00313"></a>00313     <span class="keywordtype">void</span> deleteClear(XMLCSTR lpszValue);
<a name="l00314"></a>00314 
<a name="l00315"></a>00315     <span class="comment">// The strings given as parameters for the following add and update methods (all these methods have</span>
<a name="l00316"></a>00316     <span class="comment">// a name with the postfix &quot;_WOSD&quot; that means &quot;WithOut String Duplication&quot; ) will be free&#39;d by the</span>
<a name="l00317"></a>00317     <span class="comment">// XMLNode class. For example, it means that this is incorrect:</span>
<a name="l00318"></a>00318     <span class="comment">//    xNode.addText_WOSD(&quot;foo&quot;);</span>
<a name="l00319"></a>00319     <span class="comment">//    xNode.updateAttribute_WOSD(&quot;#newcolor&quot; ,NULL,&quot;color&quot;);</span>
<a name="l00320"></a>00320     <span class="comment">// In opposition, this is correct:</span>
<a name="l00321"></a>00321     <span class="comment">//    xNode.addText(&quot;foo&quot;);</span>
<a name="l00322"></a>00322     <span class="comment">//    xNode.addText_WOSD(stringDup(&quot;foo&quot;));</span>
<a name="l00323"></a>00323     <span class="comment">//    xNode.updateAttribute(&quot;#newcolor&quot; ,NULL,&quot;color&quot;);</span>
<a name="l00324"></a>00324     <span class="comment">//    xNode.updateAttribute_WOSD(stringDup(&quot;#newcolor&quot;),NULL,&quot;color&quot;);</span>
<a name="l00325"></a>00325     <span class="comment">// Typically, you will never do:</span>
<a name="l00326"></a>00326     <span class="comment">//    char *b=(char*)malloc(...);</span>
<a name="l00327"></a>00327     <span class="comment">//    xNode.addText(b);</span>
<a name="l00328"></a>00328     <span class="comment">//    free(b);</span>
<a name="l00329"></a>00329     <span class="comment">// ... but rather:</span>
<a name="l00330"></a>00330     <span class="comment">//    char *b=(char*)malloc(...);</span>
<a name="l00331"></a>00331     <span class="comment">//    xNode.addText_WOSD(b);</span>
<a name="l00332"></a>00332     <span class="comment">//    (&#39;free(b)&#39; is performed by the XMLNode class)</span>
<a name="l00333"></a>00333 
<a name="l00334"></a>00334     <span class="keyword">static</span> <a class="code" href="structXMLNode.html">XMLNode</a> createXMLTopNode_WOSD(XMLSTR lpszName, <span class="keywordtype">char</span> isDeclaration=FALSE);
<a name="l00335"></a>00335     <a class="code" href="structXMLNode.html">XMLNode</a>        addChild_WOSD(XMLSTR lpszName, <span class="keywordtype">char</span> isDeclaration=FALSE, <span class="keywordtype">int</span> pos=-1);
<a name="l00336"></a>00336     <a class="code" href="structXMLAttribute.html">XMLAttribute</a>  *addAttribute_WOSD(XMLSTR lpszName, XMLSTR lpszValue);
<a name="l00337"></a>00337     XMLCSTR        addText_WOSD(XMLSTR lpszValue, <span class="keywordtype">int</span> pos=-1);
<a name="l00338"></a>00338     <a class="code" href="structXMLClear.html">XMLClear</a>      *addClear_WOSD(XMLSTR lpszValue, XMLCSTR lpszOpen=NULL, XMLCSTR lpszClose=NULL, <span class="keywordtype">int</span> pos=-1);
<a name="l00339"></a>00339 
<a name="l00340"></a>00340     XMLCSTR        updateName_WOSD(XMLSTR lpszName);
<a name="l00341"></a>00341     <a class="code" href="structXMLAttribute.html">XMLAttribute</a>  *updateAttribute_WOSD(<a class="code" href="structXMLAttribute.html">XMLAttribute</a> *newAttribute, <a class="code" href="structXMLAttribute.html">XMLAttribute</a> *oldAttribute);
<a name="l00342"></a>00342     <a class="code" href="structXMLAttribute.html">XMLAttribute</a>  *updateAttribute_WOSD(XMLSTR lpszNewValue, XMLSTR lpszNewName=NULL,<span class="keywordtype">int</span> i=0);
<a name="l00343"></a>00343     <a class="code" href="structXMLAttribute.html">XMLAttribute</a>  *updateAttribute_WOSD(XMLSTR lpszNewValue, XMLSTR lpszNewName,XMLCSTR lpszOldName);
<a name="l00344"></a>00344     XMLCSTR        updateText_WOSD(XMLSTR lpszNewValue, <span class="keywordtype">int</span> i=0);
<a name="l00345"></a>00345     XMLCSTR        updateText_WOSD(XMLSTR lpszNewValue, XMLCSTR lpszOldValue);
<a name="l00346"></a>00346     <a class="code" href="structXMLClear.html">XMLClear</a>      *updateClear_WOSD(XMLSTR lpszNewContent, <span class="keywordtype">int</span> i=0);
<a name="l00347"></a>00347     <a class="code" href="structXMLClear.html">XMLClear</a>      *updateClear_WOSD(<a class="code" href="structXMLClear.html">XMLClear</a> *newP,<a class="code" href="structXMLClear.html">XMLClear</a> *oldP);
<a name="l00348"></a>00348     <a class="code" href="structXMLClear.html">XMLClear</a>      *updateClear_WOSD(XMLSTR lpszNewValue, XMLCSTR lpszOldValue);
<a name="l00349"></a>00349 
<a name="l00350"></a>00350     <span class="comment">// These are some useful functions when you want to insert a childNode, a text or a XMLClearTag in the</span>
<a name="l00351"></a>00351     <span class="comment">// middle (at a specified position) of a XMLNode tree already constructed. The value returned by these</span>
<a name="l00352"></a>00352     <span class="comment">// methods is to be used as last parameter (parameter &#39;pos&#39;) of addChild, addText or addClear.</span>
<a name="l00353"></a>00353     <span class="keywordtype">int</span> positionOfText(<span class="keywordtype">int</span> i=0) <span class="keyword">const</span>;
<a name="l00354"></a>00354     <span class="keywordtype">int</span> positionOfText(XMLCSTR lpszValue) <span class="keyword">const</span>;
<a name="l00355"></a>00355     <span class="keywordtype">int</span> positionOfClear(<span class="keywordtype">int</span> i=0) <span class="keyword">const</span>;
<a name="l00356"></a>00356     <span class="keywordtype">int</span> positionOfClear(XMLCSTR lpszValue) <span class="keyword">const</span>;
<a name="l00357"></a>00357     <span class="keywordtype">int</span> positionOfClear(<a class="code" href="structXMLClear.html">XMLClear</a> *a) <span class="keyword">const</span>;
<a name="l00358"></a>00358     <span class="keywordtype">int</span> positionOfChildNode(<span class="keywordtype">int</span> i=0) <span class="keyword">const</span>;
<a name="l00359"></a>00359     <span class="keywordtype">int</span> positionOfChildNode(<a class="code" href="structXMLNode.html">XMLNode</a> x) <span class="keyword">const</span>;
<a name="l00360"></a>00360     <span class="keywordtype">int</span> positionOfChildNode(XMLCSTR name, <span class="keywordtype">int</span> i=0) <span class="keyword">const</span>; <span class="comment">// return the position of the ith childNode with the specified name</span>
<a name="l00361"></a>00361                                                           <span class="comment">// if (name==NULL) return the position of the ith childNode</span>
<a name="l00362"></a>00362 
<a name="l00363"></a>00363     <span class="comment">// The setGlobalOptions function allows you to change tree global parameters that affect string&amp;file</span>
<a name="l00364"></a>00364     <span class="comment">// parsing. First of all, you most-probably will never have to change these 3 global parameters.</span>
<a name="l00365"></a>00365     <span class="comment">// The return value of the setGlobalOptions function is &quot;0&quot; when there are no errors. If you try to</span>
<a name="l00366"></a>00366     <span class="comment">// set an unrecognized encoding then the return value will be &quot;1&quot; to signal an error.</span>
<a name="l00367"></a>00367     <span class="comment">//</span>
<a name="l00368"></a>00368     <span class="comment">// About the &quot;guessWideCharChars&quot; parameter:</span>
<a name="l00369"></a>00369     <span class="comment">//     If &quot;guessWideCharChars=1&quot; and if this library is compiled in WideChar mode, then the</span>
<a name="l00370"></a>00370     <span class="comment">//     &quot;parseFile&quot; and &quot;openFileHelper&quot; functions will test if the file contains ASCII</span>
<a name="l00371"></a>00371     <span class="comment">//     characters. If this is the case, then the file will be loaded and converted in memory to</span>
<a name="l00372"></a>00372     <span class="comment">//     WideChar before being parsed. If &quot;guessWideCharChars=0&quot;, no conversion will</span>
<a name="l00373"></a>00373     <span class="comment">//     be performed.</span>
<a name="l00374"></a>00374     <span class="comment">//</span>
<a name="l00375"></a>00375     <span class="comment">//     If &quot;guessWideCharChars=1&quot; and if this library is compiled in ASCII/UTF8/char* mode, then the</span>
<a name="l00376"></a>00376     <span class="comment">//     &quot;parseFile&quot; and &quot;openFileHelper&quot; functions will test if the file contains WideChar</span>
<a name="l00377"></a>00377     <span class="comment">//     characters. If this is the case, then the file will be loaded and converted in memory to</span>
<a name="l00378"></a>00378     <span class="comment">//     ASCII/UTF8/char* before being parsed. If &quot;guessWideCharChars=0&quot;, no conversion will</span>
<a name="l00379"></a>00379     <span class="comment">//     be performed</span>
<a name="l00380"></a>00380     <span class="comment">//</span>
<a name="l00381"></a>00381     <span class="comment">//     Sometime, it&#39;s useful to set &quot;guessWideCharChars=0&quot; to disable any conversion</span>
<a name="l00382"></a>00382     <span class="comment">//     because the test to detect the file-type (ASCII/UTF8/char* or WideChar) may fail (rarely).</span>
<a name="l00383"></a>00383     <span class="comment">//</span>
<a name="l00384"></a>00384     <span class="comment">// About the &quot;characterEncoding&quot; parameter:</span>
<a name="l00385"></a>00385     <span class="comment">//     This parameter is only meaningful when compiling in char* mode (multibyte character mode).</span>
<a name="l00386"></a>00386     <span class="comment">//     In wchar_t* (wide char mode), this parameter is ignored. This parameter should be one of the</span>
<a name="l00387"></a>00387     <span class="comment">//     three currently recognized encodings: XMLNode::encoding_UTF8, XMLNode::encoding_ascii,</span>
<a name="l00388"></a>00388     <span class="comment">//     XMLNode::encoding_ShiftJIS.</span>
<a name="l00389"></a>00389     <span class="comment">//</span>
<a name="l00390"></a>00390     <span class="comment">// About the &quot;dropWhiteSpace&quot; parameter:</span>
<a name="l00391"></a>00391     <span class="comment">//     In most situations, text fields containing only white spaces (and carriage returns)</span>
<a name="l00392"></a>00392     <span class="comment">//     are useless. Even more, these &quot;empty&quot; text fields are annoying because they increase the</span>
<a name="l00393"></a>00393     <span class="comment">//     complexity of the user&#39;s code for parsing. So, 99% of the time, it&#39;s better to drop</span>
<a name="l00394"></a>00394     <span class="comment">//     the &quot;empty&quot; text fields. However The XML specification indicates that no white spaces</span>
<a name="l00395"></a>00395     <span class="comment">//     should be lost when parsing the file. So to be perfectly XML-compliant, you should set</span>
<a name="l00396"></a>00396     <span class="comment">//     dropWhiteSpace=0. A note of caution: if you set &quot;dropWhiteSpace=0&quot;, the parser will be</span>
<a name="l00397"></a>00397     <span class="comment">//     slower and your code will be more complex.</span>
<a name="l00398"></a>00398 
<a name="l00399"></a>00399     <span class="comment">// Enumeration for XML character encoding.</span>
<a name="l00400"></a>00400     <span class="keyword">typedef</span> <span class="keyword">enum</span> XMLCharEncoding { encoding_UTF8=1, encoding_ascii=2, encoding_ShiftJIS=3 } XMLCharEncoding;
<a name="l00401"></a>00401 
<a name="l00402"></a>00402     <span class="keyword">static</span> <span class="keywordtype">char</span> setGlobalOptions(XMLCharEncoding characterEncoding=XMLNode::encoding_UTF8, <span class="keywordtype">char</span> guessWideCharChars=1, <span class="keywordtype">char</span> dropWhiteSpace=1);
<a name="l00403"></a>00403 
<a name="l00404"></a>00404     <span class="comment">// The next function try to guess the character encoding. You most-probably will never</span>
<a name="l00405"></a>00405     <span class="comment">// have to use this function. It then returns the appropriate value of the global parameter</span>
<a name="l00406"></a>00406     <span class="comment">// &quot;characterEncoding&quot; described above. The guess is based on the content of a buffer of length</span>
<a name="l00407"></a>00407     <span class="comment">// &quot;bufLen&quot; bytes that contains the first bytes (minimum 25 bytes; 200 bytes is a good value) of the</span>
<a name="l00408"></a>00408     <span class="comment">// file to be parsed. The &quot;openFileHelper&quot; function is using this function to automatically compute</span>
<a name="l00409"></a>00409     <span class="comment">// the value of the &quot;characterEncoding&quot; global parameter. There are several heuristics used to do the</span>
<a name="l00410"></a>00410     <span class="comment">// guess. One of the heuristic is based on the &quot;encoding&quot; attribute. The original XML specifications</span>
<a name="l00411"></a>00411     <span class="comment">// forbids to use this attribute to do the guess but you can still use it if you set</span>
<a name="l00412"></a>00412     <span class="comment">// &quot;useXMLEncodingAttribute&quot; to 1 (this is the default behavior and the behavior of most parsers).</span>
<a name="l00413"></a>00413     <span class="comment">// If an inconsistency in the encoding is detected, then the return value is &quot;0&quot;.</span>
<a name="l00414"></a>00414 
<a name="l00415"></a>00415     <span class="keyword">static</span> XMLCharEncoding guessCharEncoding(<span class="keywordtype">void</span> *buffer, <span class="keywordtype">int</span> bufLen, <span class="keywordtype">char</span> useXMLEncodingAttribute=1);
<a name="l00416"></a>00416 
<a name="l00417"></a>00417   <span class="keyword">private</span>:
<a name="l00418"></a>00418 
<a name="l00419"></a>00419 <span class="comment">// these are functions and structures used internally by the XMLNode class (don&#39;t bother about them):</span>
<a name="l00420"></a>00420 
<a name="l00421"></a>00421       <span class="keyword">typedef</span> <span class="keyword">struct </span>XMLNodeDataTag <span class="comment">// to allow shallow copy and &quot;intelligent/smart&quot; pointers (automatic delete):</span>
<a name="l00422"></a>00422       {
<a name="l00423"></a>00423           XMLCSTR                lpszName;        <span class="comment">// Element name (=NULL if root)</span>
<a name="l00424"></a>00424           <span class="keywordtype">int</span>                    nChild,          <span class="comment">// Number of child nodes</span>
<a name="l00425"></a>00425                                  nText,           <span class="comment">// Number of text fields</span>
<a name="l00426"></a>00426                                  nClear,          <span class="comment">// Number of Clear fields (comments)</span>
<a name="l00427"></a>00427                                  nAttribute;      <span class="comment">// Number of attributes</span>
<a name="l00428"></a>00428           <span class="keywordtype">char</span>                   isDeclaration;   <span class="comment">// Whether node is an XML declaration - &#39;&lt;?xml ?&gt;&#39;</span>
<a name="l00429"></a>00429           <span class="keyword">struct </span>XMLNodeDataTag  *pParent;        <span class="comment">// Pointer to parent element (=NULL if root)</span>
<a name="l00430"></a>00430           <a class="code" href="structXMLNode.html">XMLNode</a>                *pChild;         <span class="comment">// Array of child nodes</span>
<a name="l00431"></a>00431           XMLCSTR                *pText;          <span class="comment">// Array of text fields</span>
<a name="l00432"></a>00432           <a class="code" href="structXMLClear.html">XMLClear</a>               *pClear;         <span class="comment">// Array of clear fields</span>
<a name="l00433"></a>00433           <a class="code" href="structXMLAttribute.html">XMLAttribute</a>           *pAttribute;     <span class="comment">// Array of attributes</span>
<a name="l00434"></a>00434           <span class="keywordtype">int</span>                    *pOrder;         <span class="comment">// order of the child_nodes,text_fields,clear_fields</span>
<a name="l00435"></a>00435           <span class="keywordtype">int</span>                    ref_count;       <span class="comment">// for garbage collection (smart pointers)</span>
<a name="l00436"></a>00436       } XMLNodeData;
<a name="l00437"></a>00437       XMLNodeData *d;
<a name="l00438"></a>00438 
<a name="l00439"></a>00439       <span class="keywordtype">char</span> parseClearTag(<span class="keywordtype">void</span> *px, <span class="keywordtype">void</span> *pa);
<a name="l00440"></a>00440       <span class="keywordtype">char</span> maybeAddTxT(<span class="keywordtype">void</span> *pa, XMLCSTR tokenPStr);
<a name="l00441"></a>00441       <span class="keywordtype">int</span> ParseXMLElement(<span class="keywordtype">void</span> *pXML);
<a name="l00442"></a>00442       <span class="keywordtype">void</span> *addToOrder(<span class="keywordtype">int</span> memInc, <span class="keywordtype">int</span> *_pos, <span class="keywordtype">int</span> nc, <span class="keywordtype">void</span> *p, <span class="keywordtype">int</span> size, XMLElementType xtype);
<a name="l00443"></a>00443       <span class="keywordtype">int</span> indexText(XMLCSTR lpszValue) <span class="keyword">const</span>;
<a name="l00444"></a>00444       <span class="keywordtype">int</span> indexClear(XMLCSTR lpszValue) <span class="keyword">const</span>;
<a name="l00445"></a>00445       <a class="code" href="structXMLNode.html">XMLNode</a> addChild_priv(<span class="keywordtype">int</span>,XMLSTR,<span class="keywordtype">char</span>,<span class="keywordtype">int</span>);
<a name="l00446"></a>00446       <a class="code" href="structXMLAttribute.html">XMLAttribute</a> *addAttribute_priv(<span class="keywordtype">int</span>,XMLSTR,XMLSTR);
<a name="l00447"></a>00447       XMLCSTR addText_priv(<span class="keywordtype">int</span>,XMLSTR,<span class="keywordtype">int</span>);
<a name="l00448"></a>00448       <a class="code" href="structXMLClear.html">XMLClear</a> *addClear_priv(<span class="keywordtype">int</span>,XMLSTR,XMLCSTR,XMLCSTR,<span class="keywordtype">int</span>);
<a name="l00449"></a>00449       <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> findPosition(XMLNodeData *d, <span class="keywordtype">int</span> index, XMLElementType xtype);
<a name="l00450"></a>00450       <span class="keyword">static</span> <span class="keywordtype">int</span> CreateXMLStringR(XMLNodeData *pEntry, XMLSTR lpszMarker, <span class="keywordtype">int</span> length, <span class="keywordtype">int</span> nFormat);
<a name="l00451"></a>00451       <span class="keyword">static</span> <span class="keywordtype">int</span> removeOrderElement(XMLNodeData *d, XMLElementType t, <span class="keywordtype">int</span> index);
<a name="l00452"></a>00452       <span class="keyword">static</span> <span class="keywordtype">void</span> exactMemory(XMLNodeData *d);
<a name="l00453"></a>00453       <span class="keyword">static</span> <span class="keywordtype">int</span> detachFromParent(XMLNodeData *d);
<a name="l00454"></a>00454 } <a class="code" href="structXMLNode.html">XMLNode</a>;
<a name="l00455"></a>00455 
<a name="l00456"></a>00456 <span class="comment">// This structure is given by the function &quot;enumContents&quot;.</span>
<a name="l00457"></a><a class="code" href="structXMLNodeContents.html">00457</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structXMLNodeContents.html">XMLNodeContents</a>
<a name="l00458"></a>00458 {
<a name="l00459"></a>00459     <span class="comment">// This dictates what&#39;s the content of the XMLNodeContent</span>
<a name="l00460"></a>00460     <span class="keyword">enum</span> XMLElementType type;
<a name="l00461"></a>00461     <span class="comment">// should be an union to access the appropriate data.</span>
<a name="l00462"></a>00462     <span class="comment">// compiler does not allow union of object with constructor... too bad.</span>
<a name="l00463"></a>00463     <a class="code" href="structXMLNode.html">XMLNode</a> child;
<a name="l00464"></a>00464     <a class="code" href="structXMLAttribute.html">XMLAttribute</a> attrib;
<a name="l00465"></a>00465     XMLCSTR text;
<a name="l00466"></a>00466     <a class="code" href="structXMLClear.html">XMLClear</a> clear;
<a name="l00467"></a>00467 
<a name="l00468"></a>00468 } <a class="code" href="structXMLNodeContents.html">XMLNodeContents</a>;
<a name="l00469"></a>00469 
<a name="l00470"></a>00470 XMLDLLENTRY <span class="keywordtype">void</span> freeXMLString(XMLSTR t); <span class="comment">// {free(t);}</span>
<a name="l00471"></a>00471 
<a name="l00472"></a>00472 <span class="comment">// Duplicate (copy in a new allocated buffer) the source string. This is</span>
<a name="l00473"></a>00473 <span class="comment">// a very handy function when used with all the &quot;XMLNode::*_WOSD&quot; functions.</span>
<a name="l00474"></a>00474 <span class="comment">// (If (cbData!=0) then cbData is the number of chars to duplicate)</span>
<a name="l00475"></a>00475 XMLDLLENTRY XMLSTR stringDup(XMLCSTR source, <span class="keywordtype">int</span> cbData=0);
<a name="l00476"></a>00476 
<a name="l00477"></a>00477 <span class="comment">// The following class is processing strings so that all the characters</span>
<a name="l00478"></a>00478 <span class="comment">// &amp;,&quot;,&#39;,&lt;,&gt; are replaced by their XML equivalent: &amp;amp;, &amp;quot;, &amp;apos;, &amp;lt;, &amp;gt;.</span>
<a name="l00479"></a>00479 <span class="comment">// This  class is useful when creating from scratch an XML file using the</span>
<a name="l00480"></a>00480 <span class="comment">// &quot;printf&quot;, &quot;fprintf&quot;, &quot;cout&quot;,... functions. If you are creating from scratch an</span>
<a name="l00481"></a>00481 <span class="comment">// XML file using the provided XMLNode class you must not use the &quot;ToXMLStringTool&quot;</span>
<a name="l00482"></a>00482 <span class="comment">// class (the &quot;XMLNode&quot; class does the processing job for you during rendering).</span>
<a name="l00483"></a>00483 <span class="comment">// Using the &quot;ToXMLStringTool class&quot; and the &quot;fprintf function&quot; is THE most efficient</span>
<a name="l00484"></a>00484 <span class="comment">// way to produce VERY large XML documents VERY fast.</span>
<a name="l00485"></a><a class="code" href="structToXMLStringTool.html">00485</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>XMLDLLENTRY <a class="code" href="structToXMLStringTool.html">ToXMLStringTool</a>
<a name="l00486"></a>00486 {
<a name="l00487"></a>00487 <span class="keyword">public</span>:
<a name="l00488"></a>00488     <a class="code" href="structToXMLStringTool.html">ToXMLStringTool</a>(): buf(NULL),buflen(0){}
<a name="l00489"></a>00489     ~<a class="code" href="structToXMLStringTool.html">ToXMLStringTool</a>();
<a name="l00490"></a>00490     <span class="keywordtype">void</span> freeBuffer();
<a name="l00491"></a>00491 
<a name="l00492"></a>00492     XMLSTR toXML(XMLCSTR source);
<a name="l00493"></a>00493 
<a name="l00494"></a>00494     <span class="comment">// The next function is deprecated because there is a possibility of</span>
<a name="l00495"></a>00495     <span class="comment">// &quot;destination-buffer-overflow&quot;. It converts the string</span>
<a name="l00496"></a>00496     <span class="comment">// &quot;source&quot; to the string &quot;dest&quot;.</span>
<a name="l00497"></a>00497     <span class="keyword">static</span> XMLSTR toXMLUnSafe(XMLSTR dest,XMLCSTR source);
<a name="l00498"></a>00498 
<a name="l00499"></a>00499 <span class="keyword">private</span>:
<a name="l00500"></a>00500     XMLSTR buf;
<a name="l00501"></a>00501     <span class="keywordtype">int</span> buflen;
<a name="l00502"></a>00502 }<a class="code" href="structToXMLStringTool.html">ToXMLStringTool</a>;
<a name="l00503"></a>00503 
<a name="l00504"></a>00504 <span class="comment">// Below is a class that allows you to include any binary data (images, sounds,...)</span>
<a name="l00505"></a>00505 <span class="comment">// into an XML document using &quot;Base64 encoding&quot;. This class is completely</span>
<a name="l00506"></a>00506 <span class="comment">// separated from the rest of the xmlParser library and can be removed without any problem.</span>
<a name="l00507"></a>00507 <span class="comment">// To include some binary data into an XML file, you must convert the binary data into</span>
<a name="l00508"></a>00508 <span class="comment">// standard text (using &quot;encode&quot;). To retrieve the original binary data from the</span>
<a name="l00509"></a>00509 <span class="comment">// b64-encoded text included inside the XML file use &quot;decode&quot;. Alternatively, these</span>
<a name="l00510"></a>00510 <span class="comment">// functions can also be used to &quot;encrypt/decrypt&quot; some critical data contained inside</span>
<a name="l00511"></a>00511 <span class="comment">// the XML (it&#39;s not a strong encryption at all, but sometimes it can be useful).</span>
<a name="l00512"></a>00512 
<a name="l00513"></a><a class="code" href="structXMLParserBase64Tool.html">00513</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>XMLDLLENTRY <a class="code" href="structXMLParserBase64Tool.html">XMLParserBase64Tool</a>
<a name="l00514"></a>00514 {
<a name="l00515"></a>00515 <span class="keyword">public</span>:
<a name="l00516"></a>00516     <a class="code" href="structXMLParserBase64Tool.html">XMLParserBase64Tool</a>(): buf(NULL),buflen(0){}
<a name="l00517"></a>00517     ~<a class="code" href="structXMLParserBase64Tool.html">XMLParserBase64Tool</a>();
<a name="l00518"></a>00518     <span class="keywordtype">void</span> freeBuffer();
<a name="l00519"></a>00519 
<a name="l00520"></a>00520     <span class="comment">// returns the length of the base64 string that encodes a data buffer of size inBufLen bytes.</span>
<a name="l00521"></a>00521     <span class="comment">// If &quot;formatted&quot; parameter is true, some space will be reserved for a carriage-return every 72 chars.</span>
<a name="l00522"></a>00522     <span class="keyword">static</span> <span class="keywordtype">int</span> encodeLength(<span class="keywordtype">int</span> inBufLen, <span class="keywordtype">char</span> formatted=0);
<a name="l00523"></a>00523 
<a name="l00524"></a>00524     <span class="comment">// The &quot;base64Encode&quot; function returns a string containing the base64 encoding of &quot;inByteLen&quot; bytes</span>
<a name="l00525"></a>00525     <span class="comment">// from &quot;inByteBuf&quot;. If &quot;formatted&quot; parameter is true, then there will be a carriage-return every 72 chars.</span>
<a name="l00526"></a>00526     <span class="comment">// The string will be free&#39;d when the XMLParserBase64Tool object is deleted.</span>
<a name="l00527"></a>00527     <span class="comment">// All returned strings are sharing the same memory space.</span>
<a name="l00528"></a>00528     XMLSTR encode(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *inByteBuf, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> inByteLen, <span class="keywordtype">char</span> formatted=0);
<a name="l00529"></a>00529 
<a name="l00530"></a>00530     <span class="comment">// returns the number of bytes which will be decoded from &quot;inString&quot;.</span>
<a name="l00531"></a>00531     <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> decodeSize(XMLCSTR inString, XMLError *xe=NULL);
<a name="l00532"></a>00532 
<a name="l00533"></a>00533     <span class="comment">// returns a pointer to a buffer containing the binary data decoded from &quot;inString&quot;</span>
<a name="l00534"></a>00534     <span class="comment">// If &quot;inString&quot; is malformed NULL will be returned</span>
<a name="l00535"></a>00535     <span class="comment">// The output buffer will be free&#39;d when the XMLParserBase64Tool object is deleted.</span>
<a name="l00536"></a>00536     <span class="comment">// All output buffer are sharing the same memory space.</span>
<a name="l00537"></a>00537     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* decode(XMLCSTR inString, <span class="keywordtype">int</span> *outByteLen=NULL, XMLError *xe=NULL);
<a name="l00538"></a>00538 
<a name="l00539"></a>00539     <span class="comment">// The next function is deprecated.</span>
<a name="l00540"></a>00540     <span class="comment">// decodes data from &quot;inString&quot; to &quot;outByteBuf&quot;. You need to provide the size (in byte) of &quot;outByteBuf&quot;</span>
<a name="l00541"></a>00541     <span class="comment">// in &quot;inMaxByteOutBuflen&quot;. If &quot;outByteBuf&quot; is not large enough or if data is malformed, then &quot;FALSE&quot;</span>
<a name="l00542"></a>00542     <span class="comment">// will be returned; otherwise &quot;TRUE&quot;.</span>
<a name="l00543"></a>00543     <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> decode(XMLCSTR inString, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *outByteBuf, <span class="keywordtype">int</span> inMaxByteOutBuflen, XMLError *xe=NULL);
<a name="l00544"></a>00544 
<a name="l00545"></a>00545 <span class="keyword">private</span>:
<a name="l00546"></a>00546     <span class="keywordtype">void</span> *buf;
<a name="l00547"></a>00547     <span class="keywordtype">int</span> buflen;
<a name="l00548"></a>00548     <span class="keywordtype">void</span> alloc(<span class="keywordtype">int</span> newsize);
<a name="l00549"></a>00549 }<a class="code" href="structXMLParserBase64Tool.html">XMLParserBase64Tool</a>;
<a name="l00550"></a>00550 
<a name="l00551"></a>00551 <span class="preprocessor">#undef XMLDLLENTRY</span>
<a name="l00552"></a>00552 <span class="preprocessor"></span>
<a name="l00553"></a>00553 <span class="preprocessor">#endif</span>
</pre></div></div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Thu Nov 24 2011 23:18:06 for libmsn by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
